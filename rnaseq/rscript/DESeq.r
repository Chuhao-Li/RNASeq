library("argparse")

#input: 
#    count_table
#    coldata
#    anno
#    outdir
#    contrast
#output:
#    PCA plot
#    box plot
#    DEA result with annotation

parser <- ArgumentParser(description='Differential expression analysis by DESeq2. ')
parser$add_argument('--count_table', help=paste0('tab saperated format count table.', 
                            ' row name should be gene name, column name should be sample name. '))
parser$add_argument('--coldata', help=paste0('csv format column data of count_table. ', 
        'row name should be column name of count table, column should be properties', 
        ' of each row name. a column named "condition" is mandatory, ', 
        'a column named "batch" is optional. '))
parser$add_argument('-o', '--outdir', help='output directory')
parser$add_argument('--contrast', help=paste0('how to contract? use the format "Treat_vs_CK". ', 
        'separate multiple contrasts with comma. '))
parser$add_argument('--anno', help='annotation table. Generated by "locus_to_refseqID.py" from gff file. ')
args <- parser$parse_args()

outdir <- sub("/$", "", args$outdir)
dir.create(args$outdir, showWarnings = FALSE)
my_data <- read.csv(args$count_table, sep = '\t', row.names = 1)
coldata.tmp <- read.csv(args$coldata, row.names=1)
coldata <- coldata.tmp[colnames(my_data), , drop=F]

if(nrow(coldata.tmp) != nrow(coldata)){
    print("rownames of coldata should be the same as colnames of count table! ")
    quit()
}

library("DESeq2")
library('sva')
# 绘图相关
library("ggplot2")
library("reshape2")
library("patchwork")
library("ggdendro")

# 批次效应校正
if ("batch" %in% colnames(coldata) & length(unique(coldata$batch)) > 1){
    batch <- coldata$batch
    group <- as.numeric(as.factor(coldata$condition))
    my_data <- ComBat_seq(as.matrix(my_data), batch=batch, group=group)
}

# normalization
dds <- DESeqDataSetFromMatrix(countData = my_data,
                              colData = coldata, 
                              design = ~ condition)

dds <- DESeq(dds)
normalized <- counts(dds, normalized=TRUE) # 提取标准化后的read count
write.csv(normalized, paste0(outdir, '/normalized_readCount.csv'), quote=F)

#############################################
# 样品重复性相关图表：PCA、层次聚类、箱线图 #
#############################################

normalized.long <- melt(normalized)
vsd <- vst(dds)
p1 <- plotPCA(vsd, intgroup=c("condition")) + labs(title = "A")# PCA

# 层次聚类
normalized.diff <- normalized[colSums(normalized) != 0, ]
normalized.dist <- dist(t(normalized.diff), method = "euclidean")
normalized.hc <- hclust(d = normalized.dist, method = "ward.D2")
p1.1 <- ggdendrogram(normalized.hc) + labs(title = "B")
# 箱线图
p2 <- ggplot(normalized.long, aes(Var2, value)) + geom_boxplot() + labs(title = "C")
p3 <- ggplot(normalized.long, aes(Var2, value)) + geom_boxplot() + ylim(c(0, 5000)) + labs(title = "D")

##########################
# 组间比较。需要选择CK。 #
##########################

contrasts <- strsplit(args$contrast, ",")[[1]]

for (contrast in contrasts){
    contrast2 <- strsplit(contrast, "_vs_")[[1]]
    # contrast=c("condition", "", "")。野生型/CK应该在右边。
    res <- results(dds, contrast=c("condition", contrast2[1], contrast2[2])) 
    resOrdered <- as.data.frame(res[order(res$pvalue),])
    
    if (!is.null(args$anno)) {
        anno <- read.csv(args$anno, sep='\t')
        anno <- anno[, c('locusTag', 'product')]
        resOrdered_anno <- merge(resOrdered, anno, by.x='row.names', by.y="locusTag", sort=F)
        resOrdered_anno <- as.data.frame(resOrdered_anno[-1], row.names=resOrdered_anno[, 1])
    } else {
        resOrdered_anno <- as.data.frame(resOrdered)
    }
    
    write.csv(resOrdered_anno, paste0(outdir, '/', contrast, '.csv'), quote=F) 
}

# 拼图
pall <- (p1+p1.1)/(p2+p3)
ggsave(paste0(outdir, "/pall.png"), pall)
